{
  "type": [
    "h-entry"
  ],
  "properties": {
    "author": [
      {
        "type": [
          "h-card"
        ],
        "properties": {
          "url": [
            "/profile/cleverdevil",
            "/profile/cleverdevil"
          ],
          "photo": [
            "/file/e37c3982acf4f0a8421d085b9971cd71/thumb.jpg"
          ],
          "name": [
            "Jonathan LaCour"
          ]
        },
        "value": "Jonathan LaCour"
      }
    ],
    "name": [
      "Python Metaclasses Demystified"
    ],
    "content": [
      {
        "html": "<p><em>This article originally appeared in the July 2008 issue of Python and was adapted from Jonathan LaCour\u2019s professional Python training services. Much has changed since the article was originally published, but the principles still very much apply!</em></p><p>The word \u201cmetaclass\u201d often strikes fear into the hearts of Python programmers. This article explores metaclasses in an approachable way, in order to take the mystery out of metaclasses, and enable you to leverage metaprogramming techniques to solve real problems.</p><p>There are few things in the Python world that are so misunderstood and feared as metaclasses. In fact, when I recently was training a group of seasoned programmers about metaclasses, I asked the room what sprung to mind when they heard the word \u201cmetaclass.\u201d The students shouted out their feelings in chorus \u2013 \u201cconfusing,\u201d \u201cmagical,\u201d and worst of all, \u201cdifficult.\u201d</p><p>Well, as I told my students that day, when it comes to metaclasses, I\u2019d recommend that we called upon the wise words of Douglas Adams in his famed book \u201cThe Hitchhiker\u2019s Guide to the Galaxy.\u201d</p><blockquote><p>\u201cDon\u2019t panic!\u201d</p></blockquote><p>Once you take a closer look at how object-oriented programming works in Python, you\u2019ll quickly discover that not only are metaclasses easy, they\u2019re also extremely useful. Here, we\u2019ll do our best to take all of the mystery out of metaclasses, and show you that there\u2019s nothing to be afraid of!</p><h2>Revisiting Classes</h2><p>Most Python programmers are familiar with creating classes, and might even create or modify their own classes several times a week in the course of their work. Many of us were even taught about classes and object-oriented programming in the course of our education. But, when was the last time any of us really thought about classes in depth since we were first introduced to the concept? I\u2019d wager that most of us take classes for granted, and don\u2019t really think about what they are providing for us, and more importantly, <em>how</em> they provide it to us.</p><p>Understanding metaclasses can be greatly simplified by taking another look at Python classes, from a slightly different perspective. In order to do this, lets pose a simple question. What exactly does a class <em>do</em>?</p><p>My first instinct when attempting to answer this question is to rely on my education, which unearths big, fancy, computer-sciency words like \u201cencapsulation\u201d and \u201cabstraction.\u201d Its tempting to allow this to cloud our thinking, so lets do our best to think at a much simpler level when considering this question. So, I ask again \u2013 what does a class do?</p><p>Fundamentally, a class is used to construct objects called <em>instances</em>. This is essentially all a class does \u2013 creates instances. The process of creating instances using a class is called <em>instantiation</em>. For example, given a class <code>Person</code>, we can instantiate it to create an \u201cinstance\u201d of that <code>Person</code> class.</p><pre><br/>    class Person(object):<br/>        pass<br/><br/>    jonathan = Person()</pre><p>This instance is related back to its class in that the class is what <em>constructs</em> the instance. What do we mean by \u201cconstruct\u201d? Well, when a class is instantiated, it constructs an instance by providing it with its \u201cnamespace.\u201d We all know from Tim Peters\u2019 \u201cThe Zen of Python\u201d that namespaces are a \u201chonking great idea,\u201d and classes are a great example of why! The attributes in the namespace of a class are used to define the namespace of its instances, thus providing those instances with behavior and state. Lets enhance our <code>Person</code> class, to see how this works.</p><pre><br/>    &gt;&gt;&gt; class Person(object):<br/>    ...    greeting = 'Hello'<br/>    ...    <br/>    ...    def greet(self, who):<br/>    ...        print self.greeting, who<br/><br/>    &gt;&gt;&gt; jonathan = Person()<br/>    &gt;&gt;&gt; jonathan.greet('Readers')<br/>    'Hello Readers'</pre><p>The <code>Person</code> class now has two attributes in its namespace \u2013 <code>greeting</code> and <code>greet</code>. When we instantiate our <code>Person</code> class, our instance is given both state, in the form of the <code>greeting</code> attribute, and behavior, in the form of the <code>greet</code> method. In this way, a class is of critical and primary importance in defining how its instances will behave.</p><p>So, what does a class do? Lets summarize. In a nutshell, a class is an object with constructs instances through a process called instantiation, therefore defining the namespace, behavior, and state of that instance.</p><h2>Defining Metaclasses</h2><p>Now that we\u2019ve established clearly what a class is, we can confidently pose the question \u2013 what exactly is a metaclass? When sifting through documentation, the most common answer you\u2019ll find to that question is short, but often difficult to unpack:</p><blockquote><p>A metaclass is the class of a class.</p></blockquote><p>While this answer is certainly correct and concise, and tells us what a metaclass <em>is</em>, it still doesn\u2019t tell us what a metaclass <em>does</em>. Lets look at an alternate answer to the question:</p><blockquote><p>A metaclass is a class whose instances are classes.</p></blockquote><p>I will concede that this answer is just as much of a mouthful as its counterpart, but it has the benefit of giving us a clue as to what a metaclass <em>does</em>! In short, a metaclass constructs classes. We also know that a metaclass is just another class, and we\u2019ve just spent some time outlining what a class does. As a result, we should be able to build upon what we\u2019ve learned about classes earlier to determine a bit more about metaclasses.</p><p>Recall that a class helps define the behavior and state of its instances. Metaclasses provide the same basic capability to classes, giving you the ability to change the way a class will behave at runtime. This technique is commonly referred to as \u201cmetaprogramming.\u201d</p><p>Having a definition of metaclasses and metaprogramming is useful, but lets take a deeper look by investigating an existing metaclass.</p><h2>The <code>type</code> Metaclass</h2><p>In Python, classes which inherit from <code>object</code> are called \u201cnew-style classes.\u201d All such new-style classes have a default metaclass called <code>type</code>. We can prove that <code>type</code> is the metaclass of <code>object</code> through simple introspection in the Python interpreter. Recall, a metaclass is the class of a class, so what is the class of <code>object</code>:</p><pre><br/>    &gt;&gt;&gt; print object.__class__<br/>    &lt;type 'type'&gt;</pre><p>Just as we expected! The metaclass of <code>object</code> is <code>type</code>, and thus all classes which inherit from <code>object</code> will be provided with this metaclass by default. Classes that do not inherit from <code>object</code> are called \u201cold-style classes\u201d and will disappear in Python 3.0. While old-style classes also support metaclasses and metaprogramming, we\u2019ll focus on new-style classes in this article for the sake of simplicity.</p><p>Typically, classes are defined using the <code>class</code> statement in Python, as we saw in our earlier <code>Person</code> example. However, we have just learned that metaclasses create classes when they are instantiated. This means that we should be able to define a class by instantiating the <code>type</code> metaclass manually.</p><p>Lets define our original <code>Person</code> class again, but this time, lets do it without using the <code>class</code> statement by instantiating the <code>type</code> metaclass:</p><pre><br/>    &gt;&gt;&gt; def greet(self, who):<br/>    ...    print self.greeting, who<br/><br/>    &gt;&gt;&gt; Person = type(<br/>    ...    'Person', <br/>    ...    (object,),<br/>    ...    {'greet': greet, 'greeting': 'Hello'}<br/>    ... )<br/>    &gt;&gt;&gt;<br/>    &gt;&gt;&gt; jonathan = Person()<br/>    &gt;&gt;&gt; jonathan.greet('Readers')<br/>    'Hello Readers'</pre><p>This method of creating classes is equivalent to using the <code>class</code> statement, and reveals quite a bit about how metaclasses work. The constructor for a metaclass expects very specific arguments:</p><ol><li>The first argument is the name of the class.</li>\n<li>The second argument is a tuple of the base classes for the class.</li>\n<li>The last argument is a dictionary representing the namespace of the class. This dictionary contains all of the attributes that would typically appear within the body of a class statement.</li>\n</ol><p>Now, we\u2019ve seen a metaclass in action, and we know how to instantiate them to create classes. Armed with this knowledge of the default <code>type</code> metaclass, we can now tackle the much more interesting problem of creating our own metaclasses.</p><h2>Defining Metaclasses</h2><p>Defining metaclasses in Python is as simple as creating a class that inherits from the built-in <code>type</code> metaclass. The constructor for our metaclass will take the same arguments as the constructor for the <code>type</code> metaclass:</p><ol><li>The class name.</li>\n<li>A tuple of the class bases.</li>\n<li>A dictionary representing the namespace of the class.</li>\n</ol><p>Constructors typically perform some action on their instances, so lets make our constructor set a flag on the instance that we can inspect to make sure that our metaclass is being used.</p><pre><br/>    class MyFirstMeta(type):<br/>        def __init__(cls, name, bases, ns):<br/>            cls.uses_my_metaclass = True</pre><p>One important thing to note here is that the first argument to the constructor of a class is typically called <code>self</code>, as it refers to the instance being constructed. It is conventional to name the first argument of a metaclass constructor <code>cls</code> as the metaclass instance is actually a <em>class</em>.</p><p>Now that we\u2019ve defined our metaclass, we know that we can construct a new class called <code>MyClass</code> simply by instantiating the metaclass:</p><pre><br/>    &gt;&gt;&gt; MyClass = MyFirstMeta('MyClass', (object,), {})<br/>    &gt;&gt;&gt; print MyClass.uses_my_metaclass<br/>    True</pre><p>This very simple metaclass has given us our first glimpse into the power of metaclasses. Within our metaclass constructor, we gave our class some state in the form of a boolean attribute <code>uses_my_metaclass</code>. Metaclasses have the power to add, remove, or modify any attribute of the class being constructed. Metaclasses will frequently add or replace methods on their instances, based upon the data in the namespace of the class. Many Python object-relational mappers use metaclasses to transform the attributes of a class into database table definitions, for example.</p><p>While you can certainly construct classes by manually instantiating custom metaclasses, it is much more convenient to use the <code>class</code> statment to create your classes. Python allows you to define the metaclass for a class by using the special <code>__metaclass__</code> attribute in your class statement:</p><pre><br/>    class MyClass(object):<br/>        __metaclass__ = MyFirstMeta</pre><p>This is the preferred method of attaching metaclasses to your classes. An important thing to note about this syntax is that while you are not manually instantiating the metaclass when defining your classes this way, the Python interpeter <em>will</em> instantiate the metaclass. The metaclass instantiation will occur immediately after the class statement has been fully executed. As a result, bugs in metaclasses often are triggered during imports. In a way, the class statement is simply syntactic sugar for instantiating metaclasses!</p><h2>Mystery Metaclass Methods</h2><p>Before we move onto some practical examples of metaclasses, lets investigate metaclass definition a bit further. Our <code>Person</code> class defines a method called <code>greet</code> within its namespace. Instances of <code>Person</code> will thus have an \u201cinstance method\u201d called <code>greet</code>. We know what happens when we define methods on a class, but what happens if we define a method on a <em>metaclass</em>?</p><p>Methods defined on a class become <em>instance methods</em>. Since instances of metaclasses are <em>classes</em>, methods defined on metaclasses become _class methods_. Lets take a look at this in practice:</p><pre><br/>    &gt;&gt;&gt; class MysteryMeta(type):<br/>    &gt;&gt;&gt; ... def mystery_method(cls):<br/>    &gt;&gt;&gt; ...     return 'I am a class method!'<br/>    &gt;&gt;&gt; <br/>    &gt;&gt;&gt; class Mystery(object):<br/>            __metaclass__ = MysteryMeta<br/>    &gt;&gt;&gt; <br/>    &gt;&gt;&gt; print Mystery.mystery_method()<br/>    I am a class method!</pre><p>This revelation often surprises people, but is a logical outcome of the fact that metaclasses are simply classes which produce classes. Many metaclasses utilize this capability of defining class methods, but it is often preferable to define such class methods on a base class, which is easier to document and understand.</p><p>We\u2019ve now established what metaclasses are, how they work, and how we can define our own by inheriting from <code>type</code>. But, what about practical use cases for metaclasses? Lets take a look at several examples of how we might come to use metaprogramming in practice.</p><h2>Example: The Enforcer</h2><p>When I am teaching Python to programmers with strong backgrounds in \u201cbondage and discipline\u201d languages like Java, I frequently hear the same complaints about Python. One such complaint is that class definitions are \u201cloose\u201d and you cannot enforce the type of variables by declaring them up-front. In order to illustrate how to use metaclasses, lets define a little library that will address this particular complaint.</p><p>Our goal is to create a base class called <code>Enforcer</code> that will enforce the types of attributes on its subclasses. Lets say we wanted to enforce that the <code>name</code> attribte of our <code>Person</code> class was a string, and that the <code>age</code> attribute was an integer. Attempting to set attribtues with the wrong type should trigger a <code>TypeError</code> to be raised, just like the Java compiler would catch such errors.</p><pre><br/>    class Person(Enforcer):<br/>        name = Field(str)<br/>        age = Field(int)</pre><p>The first thing we need to do is define the <code>Field</code> class, which we will use to hold onto the type of the variable we\u2019re attempting to restrict. Lets also give it the ability to validate whether or not a value is of the right type for that particular attribute:</p><pre><br/>    class Field(object):<br/>        def __init__(self, ftype):<br/>            self.ftype = ftype<br/><br/>        def is_valid(self, value):<br/>            return isinstance(value, self.ftype)</pre><p>Now that we have our <code>Field</code> class, we need to create a metaclass that will look at the namespace of our class, searching for <code>Field</code> definitions, and then storing them in a dictionary for later use. Recall that the last argument to the constructor of a metaclass is a dictionary containing the namespace of the class. We can loop through this namespace to find <code>Field</code> definitions:</p><pre><br/>    class EnforcerMeta(type):<br/>        def __init__(cls, name, bases, ns):<br/>            # store the field definitions on the class as a dictionary <br/>            # mapping the field name to the Field instance.<br/>            cls._fields = {}<br/><br/>            # loop through the namespace looking for Field instances<br/>            for key, value in ns.items():<br/>                if isinstance(value, Field):<br/>                    cls._fields[key] = value</pre><p>Our metaclass first attaches a <code>_fields</code> dictionary to the class itself. This data structure is where we will store <code>Field</code> definitions for later use. We then loop through the items in the namespace looking for <code>Field</code> instances, and finally we store them in our <code>_fields</code> dictionary.</p><p>Next up is the <code>Enforcer</code> base class itself. The <code>Enforcer</code> base class first needs to attach the <code>EnforcerMeta</code> metaclass we\u2019ve just defined. This is a very common way for libraries to distribute their metaclasses, by defining a base class to inherit from, rather than requiring users to even know that a metaclass is being used, or how to attach the metaclass to their classes.</p><p>The second thing the <code>Enforcer</code> base class needs to do is to override the <code>__setattr__</code> method. This is a special method on Python classes that allows you to override the default attribute setting behavior on your Python objects. The <code>__setattr__</code> method takes in the name of the attribute being set, and the value being set.</p><pre><br/>    class Enforcer(object):<br/>        # attach the metaclass<br/>        __metaclass__ = EnforcerMeta<br/><br/>        def __setattr__(self, key, value):<br/>            if key in self._fields:<br/>                if not self._fields[key].is_valid(value):<br/>                    raise TypeError('Invalid type for field!')<br/>            super(Enforcer, self).__setattr__(key, value)</pre><p>Our <code>Enforcer</code> class first attaches the metaclass. Then, it overrides the <code>__setattr__</code> method so that it can watch for field assignments. First, we check to see if the attribute being set is one of our defined fields. Then, we ask the field definition if the value that is being passed is valid for the field definition. If it is not a valid type for the field, we raise a <code>TypeError</code>.</p><p>The last line of the <code>Enforcer</code> class is extremely important. This line is instructing the Python interpreter to call the <code>__setattr__</code> implementation on the appropriate superclass definition, in this case <code>object</code>. Without this line, attribute setting would fail on all <code>Enforcer</code> subclasses.</p><p>Lets try out our new creation from the Python interactive prompt:</p><pre><br/>    &gt;&gt;&gt; class Person(Enforcer):<br/>    ...    name = Field(str)<br/>    ...    age = Field(int)<br/>    ... <br/>    &gt;&gt;&gt; jonathan = Person()<br/>    &gt;&gt;&gt; jonathan.name = 3<br/>    TypeError: Invalid type<br/>    &gt;&gt;&gt; jonathan.age = 'Old'<br/>    TypeError: Invalid type<br/>    &gt;&gt;&gt; jonathan.name = 'Jonathan'<br/>    &gt;&gt;&gt; jonathan.age = 28</pre><p>Our metaclass has completely changed the way that our class behaves, transforming it into a more rigid class definition that keeps our Java-loving friends happy. While such restrictive enforcement is atypical in Python, it certainly shows how powerful metaclasses can be.</p><p>This example also illustrates a common pattern for metaclasses, in which a class describes how it wants to behave in a \u201cdeclarative\u201d way without actually writing any code to implement that behavior. The metaclass subsequently takes that metadata, and uses it to \u201creprogram\u201d the class. This is the essence of what metaprogramming brings to the table, and is the most popular use-case for metaclasses.</p><h2>Example: Auto Decorator</h2><p>Since being given a special syntax in Python 2.4, decorators have become a very commonly used feature. A decorator is essentially a wrapper around a function or method. In versions of Python prior to 2.4, decorators were applied by manually replacing the method definition with a \u201cdecorated\u201d version of the method. Starting in Python 2.4, decorators could be applied using the now popular <code>@decorator</code> syntax.</p><p>Sometimes, I find myself in the situation where I need to decorate all of the methods of a class with the same decorator. Lets create a metaclass that will simplify this process by automatically applying a decorator that is declared in the namespace of the class:</p><pre><br/>    import inspect<br/><br/>    class AutoDecorateMeta(type):<br/>        def __init__(cls, name, bases, ns):<br/>            deco = ns.get('decorator', lambda f: f)<br/>            for key, value in ns.items():<br/>                # skip the decorator and constructor<br/>                if key in ('decorator', '__init__'): continue<br/><br/>                # skip objects in the namespace that aren't methods<br/>                if not inspect.isfunction(value): continue<br/><br/>                # apply the decorator<br/>                setattr(cls, key, deco(value))</pre><p>Our metaclass first looks up an attribute named <code>decorator</code> in the namespace of the class. This is the decorator that we will apply to every method of the class. Note that if such a decorator cannot be found in the namespace of the class, we define a fake decorator that will simply return the existing method definition.</p><p>Next, we loop through the namespace of the class looking for methods. If we encounter the decorator or the constructor, we skip them, as we don\u2019t want to decorate our constructor or the decorator itself. We then make use of the <code>inspect</code> module to determine if the value is a method, and if it is, we replace the method definition with a decorated version of that method.</p><p>Lets put our metaclass to the test by creating a class that defines several properties. Typically, we\u2019d have to decorate every method with the <code>@property</code> decorator, which could add a lot of verbosity to our class, depending on the number of methods we\u2019d have to decorate.</p><pre><br/>    class Person(object):<br/>        __metaclass__ = AutoDecorateMeta<br/>        decorator = property<br/><br/>        def __init__(self, first, middle, last):<br/>            self.first = first<br/>            self.middle = middle<br/>            self.last = last<br/><br/>        def name(self):<br/>            return '%s %s' % (self.first, self.last)<br/><br/>        def full_name(self):<br/>            return '%s %s %s' % (self.first, self.middle, self.last)<br/><br/>        def initials(self):<br/>            return '%s%s%s' % (self.first[0], self.middle[0], self.last[0])</pre><p>Now that we\u2019ve created our class, we should be able to try it out from our Python interactive prompt to see if all of our methods were transformed into properties:</p><pre>    <br/>    &gt;&gt;&gt; mlk = Person('Martin', 'Luther', 'King')<br/>    &gt;&gt;&gt; print mlk.name<br/>    Martin King<br/>    &gt;&gt;&gt; print mlk.full_name<br/>    Martin Luther King<br/>    &gt;&gt;&gt; print mlk.initials<br/>    MLK</pre><p>Not only is this example useful in practice, it also illustrates another use case for metaclasses and metaprogramming \u2013 automating repetitive tasks that occur in class definition. This metaclass could be used to wrap every method of a class in a transaction, to add debugging hooks, or even to synchronize all of the methods using a thread lock.</p><h2>Cautionary Notes</h2><p>Metaclasses are fantastically cool, and as we\u2019ve seen, they can be pretty useful. The rise of object-relational mappers and web frameworks have put metaclasses into use by an increasing number of Python users, and has increased the visibility of metaclasses substantially. That being said, metaclasses are a feature of Python that must be used carefully. Because metaclasses do their work at class definition time, bugs in your metaclasses can result in errors that are triggered at import time. In addition, metaclasses are often hidden from the programmer behind a base class, which can cause confusion.</p><p>Applied judiciously, metaclasses can be a great tool for solving problems, and give Python programmers the ability to take advantage of metaprogramming techniques in their own code. I hope that this article has shed some light on what metaclasses are, and has taken some of the mystery out of metaclasses.</p>",
        "value": "This article originally appeared in the July 2008 issue of Python and was adapted from Jonathan LaCour\u2019s professional Python training services. Much has changed since the article was originally published, but the principles still very much apply!\nThe word \u201cmetaclass\u201d often strikes fear into the hearts of Python programmers. This article explores metaclasses in an approachable way, in order to take the mystery out of metaclasses, and enable you to leverage metaprogramming techniques to solve real problems.\nThere are few things in the Python world that are so misunderstood and feared as metaclasses. In fact, when I recently was training a group of seasoned programmers about metaclasses, I asked the room what sprung to mind when they heard the word \u201cmetaclass.\u201d The students shouted out their feelings in chorus \u2013 \u201cconfusing,\u201d \u201cmagical,\u201d and worst of all, \u201cdifficult.\u201d\nWell, as I told my students that day, when it comes to metaclasses, I\u2019d recommend that we called upon the wise words of Douglas Adams in his famed book \u201cThe Hitchhiker\u2019s Guide to the Galaxy.\u201d\n\u201cDon\u2019t panic!\u201d\nOnce you take a closer look at how object-oriented programming works in Python, you\u2019ll quickly discover that not only are metaclasses easy, they\u2019re also extremely useful. Here, we\u2019ll do our best to take all of the mystery out of metaclasses, and show you that there\u2019s nothing to be afraid of!Revisiting Classes\nMost Python programmers are familiar with creating classes, and might even create or modify their own classes several times a week in the course of their work. Many of us were even taught about classes and object-oriented programming in the course of our education. But, when was the last time any of us really thought about classes in depth since we were first introduced to the concept? I\u2019d wager that most of us take classes for granted, and don\u2019t really think about what they are providing for us, and more importantly, how they provide it to us.\nUnderstanding metaclasses can be greatly simplified by taking another look at Python classes, from a slightly different perspective. In order to do this, lets pose a simple question. What exactly does a class do?\nMy first instinct when attempting to answer this question is to rely on my education, which unearths big, fancy, computer-sciency words like \u201cencapsulation\u201d and \u201cabstraction.\u201d Its tempting to allow this to cloud our thinking, so lets do our best to think at a much simpler level when considering this question. So, I ask again \u2013 what does a class do?\nFundamentally, a class is used to construct objects called instances. This is essentially all a class does \u2013 creates instances. The process of creating instances using a class is called instantiation. For example, given a class Person, we can instantiate it to create an \u201cinstance\u201d of that Person class.    class Person(object):        pass    jonathan = Person()\nThis instance is related back to its class in that the class is what constructs the instance. What do we mean by \u201cconstruct\u201d? Well, when a class is instantiated, it constructs an instance by providing it with its \u201cnamespace.\u201d We all know from Tim Peters\u2019 \u201cThe Zen of Python\u201d that namespaces are a \u201chonking great idea,\u201d and classes are a great example of why! The attributes in the namespace of a class are used to define the namespace of its instances, thus providing those instances with behavior and state. Lets enhance our Person class, to see how this works.    >>> class Person(object):    ...    greeting = 'Hello'    ...        ...    def greet(self, who):    ...        print self.greeting, who    >>> jonathan = Person()    >>> jonathan.greet('Readers')    'Hello Readers'\nThe Person class now has two attributes in its namespace \u2013 greeting and greet. When we instantiate our Person class, our instance is given both state, in the form of the greeting attribute, and behavior, in the form of the greet method. In this way, a class is of critical and primary importance in defining how its instances will behave.\nSo, what does a class do? Lets summarize. In a nutshell, a class is an object with constructs instances through a process called instantiation, therefore defining the namespace, behavior, and state of that instance.Defining Metaclasses\nNow that we\u2019ve established clearly what a class is, we can confidently pose the question \u2013 what exactly is a metaclass? When sifting through documentation, the most common answer you\u2019ll find to that question is short, but often difficult to unpack:\nA metaclass is the class of a class.\nWhile this answer is certainly correct and concise, and tells us what a metaclass is, it still doesn\u2019t tell us what a metaclass does. Lets look at an alternate answer to the question:\nA metaclass is a class whose instances are classes.\nI will concede that this answer is just as much of a mouthful as its counterpart, but it has the benefit of giving us a clue as to what a metaclass does! In short, a metaclass constructs classes. We also know that a metaclass is just another class, and we\u2019ve just spent some time outlining what a class does. As a result, we should be able to build upon what we\u2019ve learned about classes earlier to determine a bit more about metaclasses.\nRecall that a class helps define the behavior and state of its instances. Metaclasses provide the same basic capability to classes, giving you the ability to change the way a class will behave at runtime. This technique is commonly referred to as \u201cmetaprogramming.\u201d\nHaving a definition of metaclasses and metaprogramming is useful, but lets take a deeper look by investigating an existing metaclass.The type Metaclass\nIn Python, classes which inherit from object are called \u201cnew-style classes.\u201d All such new-style classes have a default metaclass called type. We can prove that type is the metaclass of object through simple introspection in the Python interpreter. Recall, a metaclass is the class of a class, so what is the class of object:    >>> print object.__class__    <type 'type'>\nJust as we expected! The metaclass of object is type, and thus all classes which inherit from object will be provided with this metaclass by default. Classes that do not inherit from object are called \u201cold-style classes\u201d and will disappear in Python 3.0. While old-style classes also support metaclasses and metaprogramming, we\u2019ll focus on new-style classes in this article for the sake of simplicity.\nTypically, classes are defined using the class statement in Python, as we saw in our earlier Person example. However, we have just learned that metaclasses create classes when they are instantiated. This means that we should be able to define a class by instantiating the type metaclass manually.\nLets define our original Person class again, but this time, lets do it without using the class statement by instantiating the type metaclass:    >>> def greet(self, who):    ...    print self.greeting, who    >>> Person = type(    ...    'Person',     ...    (object,),    ...    {'greet': greet, 'greeting': 'Hello'}    ... )    >>>    >>> jonathan = Person()    >>> jonathan.greet('Readers')    'Hello Readers'\nThis method of creating classes is equivalent to using the class statement, and reveals quite a bit about how metaclasses work. The constructor for a metaclass expects very specific arguments:The first argument is the name of the class. The second argument is a tuple of the base classes for the class. The last argument is a dictionary representing the namespace of the class. This dictionary contains all of the attributes that would typically appear within the body of a class statement.\nNow, we\u2019ve seen a metaclass in action, and we know how to instantiate them to create classes. Armed with this knowledge of the default type metaclass, we can now tackle the much more interesting problem of creating our own metaclasses.Defining Metaclasses\nDefining metaclasses in Python is as simple as creating a class that inherits from the built-in type metaclass. The constructor for our metaclass will take the same arguments as the constructor for the type metaclass:The class name. A tuple of the class bases. A dictionary representing the namespace of the class.\nConstructors typically perform some action on their instances, so lets make our constructor set a flag on the instance that we can inspect to make sure that our metaclass is being used.    class MyFirstMeta(type):        def __init__(cls, name, bases, ns):            cls.uses_my_metaclass = True\nOne important thing to note here is that the first argument to the constructor of a class is typically called self, as it refers to the instance being constructed. It is conventional to name the first argument of a metaclass constructor cls as the metaclass instance is actually a class.\nNow that we\u2019ve defined our metaclass, we know that we can construct a new class called MyClass simply by instantiating the metaclass:    >>> MyClass = MyFirstMeta('MyClass', (object,), {})    >>> print MyClass.uses_my_metaclass    True\nThis very simple metaclass has given us our first glimpse into the power of metaclasses. Within our metaclass constructor, we gave our class some state in the form of a boolean attribute uses_my_metaclass. Metaclasses have the power to add, remove, or modify any attribute of the class being constructed. Metaclasses will frequently add or replace methods on their instances, based upon the data in the namespace of the class. Many Python object-relational mappers use metaclasses to transform the attributes of a class into database table definitions, for example.\nWhile you can certainly construct classes by manually instantiating custom metaclasses, it is much more convenient to use the class statment to create your classes. Python allows you to define the metaclass for a class by using the special __metaclass__ attribute in your class statement:    class MyClass(object):        __metaclass__ = MyFirstMeta\nThis is the preferred method of attaching metaclasses to your classes. An important thing to note about this syntax is that while you are not manually instantiating the metaclass when defining your classes this way, the Python interpeter will instantiate the metaclass. The metaclass instantiation will occur immediately after the class statement has been fully executed. As a result, bugs in metaclasses often are triggered during imports. In a way, the class statement is simply syntactic sugar for instantiating metaclasses!Mystery Metaclass Methods\nBefore we move onto some practical examples of metaclasses, lets investigate metaclass definition a bit further. Our Person class defines a method called greet within its namespace. Instances of Person will thus have an \u201cinstance method\u201d called greet. We know what happens when we define methods on a class, but what happens if we define a method on a metaclass?\nMethods defined on a class become instance methods. Since instances of metaclasses are classes, methods defined on metaclasses become _class methods_. Lets take a look at this in practice:    >>> class MysteryMeta(type):    >>> ... def mystery_method(cls):    >>> ...     return 'I am a class method!'    >>>     >>> class Mystery(object):            __metaclass__ = MysteryMeta    >>>     >>> print Mystery.mystery_method()    I am a class method!\nThis revelation often surprises people, but is a logical outcome of the fact that metaclasses are simply classes which produce classes. Many metaclasses utilize this capability of defining class methods, but it is often preferable to define such class methods on a base class, which is easier to document and understand.\nWe\u2019ve now established what metaclasses are, how they work, and how we can define our own by inheriting from type. But, what about practical use cases for metaclasses? Lets take a look at several examples of how we might come to use metaprogramming in practice.Example: The Enforcer\nWhen I am teaching Python to programmers with strong backgrounds in \u201cbondage and discipline\u201d languages like Java, I frequently hear the same complaints about Python. One such complaint is that class definitions are \u201cloose\u201d and you cannot enforce the type of variables by declaring them up-front. In order to illustrate how to use metaclasses, lets define a little library that will address this particular complaint.\nOur goal is to create a base class called Enforcer that will enforce the types of attributes on its subclasses. Lets say we wanted to enforce that the name attribte of our Person class was a string, and that the age attribute was an integer. Attempting to set attribtues with the wrong type should trigger a TypeError to be raised, just like the Java compiler would catch such errors.    class Person(Enforcer):        name = Field(str)        age = Field(int)\nThe first thing we need to do is define the Field class, which we will use to hold onto the type of the variable we\u2019re attempting to restrict. Lets also give it the ability to validate whether or not a value is of the right type for that particular attribute:    class Field(object):        def __init__(self, ftype):            self.ftype = ftype        def is_valid(self, value):            return isinstance(value, self.ftype)\nNow that we have our Field class, we need to create a metaclass that will look at the namespace of our class, searching for Field definitions, and then storing them in a dictionary for later use. Recall that the last argument to the constructor of a metaclass is a dictionary containing the namespace of the class. We can loop through this namespace to find Field definitions:    class EnforcerMeta(type):        def __init__(cls, name, bases, ns):            # store the field definitions on the class as a dictionary             # mapping the field name to the Field instance.            cls._fields = {}            # loop through the namespace looking for Field instances            for key, value in ns.items():                if isinstance(value, Field):                    cls._fields[key] = value\nOur metaclass first attaches a _fields dictionary to the class itself. This data structure is where we will store Field definitions for later use. We then loop through the items in the namespace looking for Field instances, and finally we store them in our _fields dictionary.\nNext up is the Enforcer base class itself. The Enforcer base class first needs to attach the EnforcerMeta metaclass we\u2019ve just defined. This is a very common way for libraries to distribute their metaclasses, by defining a base class to inherit from, rather than requiring users to even know that a metaclass is being used, or how to attach the metaclass to their classes.\nThe second thing the Enforcer base class needs to do is to override the __setattr__ method. This is a special method on Python classes that allows you to override the default attribute setting behavior on your Python objects. The __setattr__ method takes in the name of the attribute being set, and the value being set.    class Enforcer(object):        # attach the metaclass        __metaclass__ = EnforcerMeta        def __setattr__(self, key, value):            if key in self._fields:                if not self._fields[key].is_valid(value):                    raise TypeError('Invalid type for field!')            super(Enforcer, self).__setattr__(key, value)\nOur Enforcer class first attaches the metaclass. Then, it overrides the __setattr__ method so that it can watch for field assignments. First, we check to see if the attribute being set is one of our defined fields. Then, we ask the field definition if the value that is being passed is valid for the field definition. If it is not a valid type for the field, we raise a TypeError.\nThe last line of the Enforcer class is extremely important. This line is instructing the Python interpreter to call the __setattr__ implementation on the appropriate superclass definition, in this case object. Without this line, attribute setting would fail on all Enforcer subclasses.\nLets try out our new creation from the Python interactive prompt:    >>> class Person(Enforcer):    ...    name = Field(str)    ...    age = Field(int)    ...     >>> jonathan = Person()    >>> jonathan.name = 3    TypeError: Invalid type    >>> jonathan.age = 'Old'    TypeError: Invalid type    >>> jonathan.name = 'Jonathan'    >>> jonathan.age = 28\nOur metaclass has completely changed the way that our class behaves, transforming it into a more rigid class definition that keeps our Java-loving friends happy. While such restrictive enforcement is atypical in Python, it certainly shows how powerful metaclasses can be.\nThis example also illustrates a common pattern for metaclasses, in which a class describes how it wants to behave in a \u201cdeclarative\u201d way without actually writing any code to implement that behavior. The metaclass subsequently takes that metadata, and uses it to \u201creprogram\u201d the class. This is the essence of what metaprogramming brings to the table, and is the most popular use-case for metaclasses.Example: Auto Decorator\nSince being given a special syntax in Python 2.4, decorators have become a very commonly used feature. A decorator is essentially a wrapper around a function or method. In versions of Python prior to 2.4, decorators were applied by manually replacing the method definition with a \u201cdecorated\u201d version of the method. Starting in Python 2.4, decorators could be applied using the now popular @decorator syntax.\nSometimes, I find myself in the situation where I need to decorate all of the methods of a class with the same decorator. Lets create a metaclass that will simplify this process by automatically applying a decorator that is declared in the namespace of the class:    import inspect    class AutoDecorateMeta(type):        def __init__(cls, name, bases, ns):            deco = ns.get('decorator', lambda f: f)            for key, value in ns.items():                # skip the decorator and constructor                if key in ('decorator', '__init__'): continue                # skip objects in the namespace that aren't methods                if not inspect.isfunction(value): continue                # apply the decorator                setattr(cls, key, deco(value))\nOur metaclass first looks up an attribute named decorator in the namespace of the class. This is the decorator that we will apply to every method of the class. Note that if such a decorator cannot be found in the namespace of the class, we define a fake decorator that will simply return the existing method definition.\nNext, we loop through the namespace of the class looking for methods. If we encounter the decorator or the constructor, we skip them, as we don\u2019t want to decorate our constructor or the decorator itself. We then make use of the inspect module to determine if the value is a method, and if it is, we replace the method definition with a decorated version of that method.\nLets put our metaclass to the test by creating a class that defines several properties. Typically, we\u2019d have to decorate every method with the @property decorator, which could add a lot of verbosity to our class, depending on the number of methods we\u2019d have to decorate.    class Person(object):        __metaclass__ = AutoDecorateMeta        decorator = property        def __init__(self, first, middle, last):            self.first = first            self.middle = middle            self.last = last        def name(self):            return '%s %s' % (self.first, self.last)        def full_name(self):            return '%s %s %s' % (self.first, self.middle, self.last)        def initials(self):            return '%s%s%s' % (self.first[0], self.middle[0], self.last[0])\nNow that we\u2019ve created our class, we should be able to try it out from our Python interactive prompt to see if all of our methods were transformed into properties:        >>> mlk = Person('Martin', 'Luther', 'King')    >>> print mlk.name    Martin King    >>> print mlk.full_name    Martin Luther King    >>> print mlk.initials    MLK\nNot only is this example useful in practice, it also illustrates another use case for metaclasses and metaprogramming \u2013 automating repetitive tasks that occur in class definition. This metaclass could be used to wrap every method of a class in a transaction, to add debugging hooks, or even to synchronize all of the methods using a thread lock.Cautionary Notes\nMetaclasses are fantastically cool, and as we\u2019ve seen, they can be pretty useful. The rise of object-relational mappers and web frameworks have put metaclasses into use by an increasing number of Python users, and has increased the visibility of metaclasses substantially. That being said, metaclasses are a feature of Python that must be used carefully. Because metaclasses do their work at class definition time, bugs in your metaclasses can result in errors that are triggered at import time. In addition, metaclasses are often hidden from the programmer behind a base class, which can cause confusion.\nApplied judiciously, metaclasses can be a great tool for solving problems, and give Python programmers the ability to take advantage of metaprogramming techniques in their own code. I hope that this article has shed some light on what metaclasses are, and has taken some of the mystery out of metaclasses."
      }
    ],
    "url": [
      "/2009/python-metaclasses-demystified"
    ],
    "published": [
      "2009-01-10T12:30:00+0000"
    ],
    "post-kind": [
      "Entry"
    ],
    "post-id": [
      "fc04cb70e0b80175b8237436cace3260"
    ]
  }
}